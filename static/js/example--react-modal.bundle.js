(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{83:function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return u});var n=a(0),o=a.n(n),l=a(8),i=a(105),r=a(106),s=a(3),h=a(107),c={title:"Modal Routes"};function u(){return o.a.createElement(o.a.Fragment,null,o.a.createElement("h1",null,c.title),o.a.createElement(i.a,{title:"Explanation",id:"explanation"},o.a.createElement(s.b,null,o.a.createElement("p",null,"This example mimics the way that Pinterest works. Whether or not this is a good design pattern is up for debate, but at the very least it is helpful to see one way that you can do this with Curi."),o.a.createElement("p",null,'When you navigate to a "modal route" from within the application, the content will be displayed in a modal window (preserving the background content from the page that the user navigated from). If you load the same location manually, it will render the location in a full window.'),o.a.createElement("p",null,o.a.createElement(l.b,null,"navigation.previous")," is used to render the base layer displayed under the modal. ",o.a.createElement(l.b,null,"previous")," is the previous location's ",o.a.createElement(l.b,null,"response")," object."),o.a.createElement("p",null,"Knowing whether to render a modal window or a full page can be tricky. One approach is to use ",o.a.createElement(l.b,null,"location.state")," to attach a value to the location that indicates that you want to render a modal. The downside of using state is that is is persistent across refreshes and the user clicking the browser's forward/back buttons, which means that you also have to take those into consideration when testing the modal's behavior."))),o.a.createElement(i.a,{title:"Live Demo",id:"demo"},o.a.createElement(r.a,{id:"github/pshrmn/curi/tree/master/examples/react/modal"})),o.a.createElement(h.a,{path:"react/modal"}))}}}]);